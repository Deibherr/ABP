<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Competencia de Rodadura 3D (Completo)</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#071226; --panel:#0b1220; --muted:#9aa8bd; --accent:#38bdf8;
      --card:#0b1220; --white: #e6eef8;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071226 0%, #061827 100%);color:var(--white)}
    .app{display:grid;grid-template-columns:1fr 420px;gap:18px;padding:18px;height:100vh;align-items:stretch}
    
    /* stage (left) */
    .stage{
      background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.4));
      border-radius:10px;padding:0;display:flex;flex-direction:column;min-height:0;overflow:hidden;position:relative;
    }
    #sketch-holder{flex:1;display:flex;align-items:center;justify-content:center;min-height:0;overflow:hidden}
    
    /* overlay UI on stage */
    .stage-overlay{
      position:absolute; top:10px; left:10px; right:10px; pointer-events:none;
      display:flex; justify-content:space-between; z-index:10;
    }
    .stage-overlay .badge{
      background:rgba(0,0,0,0.6); padding:6px 12px; border-radius:20px; 
      backdrop-filter:blur(4px); font-size:13px; display:flex; align-items:center; gap:8px; pointer-events:auto;
    }

    /* right panel */
    .controls{background:rgba(6,10,15,0.62);border-radius:10px;padding:14px;display:flex;flex-direction:column;gap:10px;overflow:auto;max-height:100%}
    label{font-size:13px;color:var(--muted);min-width:110px}
    .row{display:flex;gap:8px;align-items:center}
    input[type=range]{width:100%}
    .buttons{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);border:none;padding:8px 10px;border-radius:8px;color:#042233;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    button:hover{opacity:0.9}
    
    .metrics{display:grid;grid-template-columns:repeat(2,1fr);gap:6px}
    .metric{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-size:13px}
    .small{font-size:12px;color:var(--muted)}
    
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block}
    .dot.sphere{background:#ff9f1c}
    .dot.cyl{background:#2bd0a3}
    .dot.ring{background:#a5b4fc}

    .log{background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;max-height:160px;overflow:auto;font-size:13px}
    canvas{border-radius:8px;display:block}
    .title{font-weight:700;color:#fff;margin-bottom:6px}
    .graph-wrap{background:transparent;padding:8px;border-radius:8px}
    .history{background:rgba(255,255,255,0.02);border-radius:8px;padding:8px;max-height:140px;overflow:auto}
    .footer-note{font-size:12px;color:var(--muted);margin-top:6px}
    .small-muted{font-size:12px;color:var(--muted)}

    /* responsive */
    @media (max-width:1000px){
      .app{grid-template-columns:1fr;grid-auto-rows:auto}
      .controls{height:auto}
      .stage{height:400px}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage" id="stage">
      <div class="stage-overlay">
        <div class="badge">
          <div class="dot sphere"></div> Esfera
          <div class="dot cyl" style="margin-left:4px"></div> Cilindro
          <div class="dot ring" style="margin-left:4px"></div> Aro
        </div>
        <div class="badge">
          <span class="small-muted" style="color:#fff">Click y arrastra para rotar c√°mara</span>
        </div>
      </div>

      <div id="sketch-holder"></div>

      <div style="position:absolute; bottom:10px; left:10px; right:10px; display:flex; justify-content:space-between; pointer-events:none">
        <div class="badge">t = <span id="t">0.000</span> s</div>
        <div class="badge">Estado: <span id="status">Detenido</span></div>
      </div>
    </div>

    <div class="controls">
      <div class="title">Controles F√≠sica 3D</div>

      <div class="row"><label>√Ångulo Œ∏ (¬∞)</label><input id="angle" type="range" min="1" max="45" value="20"><div class="small" id="angle-val">20¬∞</div></div>
      <div class="row"><label>Altura h (m)</label><input id="height" type="range" min="0.2" max="3.0" step="0.01" value="1.2"><div class="small" id="height-val">1.20 m</div></div>
      <div class="row"><label>Radio R (m)</label><input id="radius" type="range" min="0.02" max="0.2" step="0.005" value="0.1"><div class="small" id="radius-val">0.100 m</div></div>
      <div class="row"><label>Masa m (kg)</label><input id="mass" type="range" min="0.1" max="5.0" step="0.1" value="1.0"><div class="small" id="mass-val">1.0 kg</div></div>

      <div class="row buttons">
        <button id="start">Iniciar</button>
        <button id="pause" class="secondary">Pausar</button>
        <button id="reset" class="secondary">Reset</button>
        <button id="viewReset" class="secondary" style="font-size:11px">Cam Reset</button>
        <button id="exportSnapshot" class="secondary" style="font-size:11px">Snapshot CSV</button>
      </div>

      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between; margin-top:5px">
        <div style="display:flex;gap:8px;align-items:center"><input id="showForces" type="checkbox"><div class="small-muted">Vectores Fuerza</div></div>
        <div style="display:flex;gap:8px;align-items:center"><input id="showTrail" type="checkbox" checked><div class="small-muted">Rastro</div></div>
      </div>

      <div class="metrics" style="margin-top:6px">
        <div class="metric">Œ∏ = <span id="tangle">20</span>¬∞</div>
<div class="metrics" style="margin-top:6px">
  <div class="metric">s(t): <span id="posText">0.000</span> m</div>
  <div class="metric">œâ(t): <span id="omegaText">0.000</span> rad/s</div>
</div>
<div class="metrics" style="margin-top:6px">
  <div class="metric">t final Esfera: <span id="tEsfera">--</span>s</div>
  <div class="metric">t final Cilindro: <span id="tCilindro">--</span>s</div>
  <div class="metric">t final Aro: <span id="tAro">--</span>s</div>
</div>

        <div class="metric">a (te√≥rica): <span id="a_theo">-</span> m/s¬≤</div>
        <div class="metric">Esfera: v=<span id="v_sphere">0.000</span></div>
        <div class="metric">Cilindro: v=<span id="v_cyl">0.000</span></div>
        <div class="metric">Aro: v=<span id="v_ring">0.000</span></div>
      </div>

      <div style="margin-top:8px">
        <div class="small-muted" style="margin-bottom:6px">Gr√°fica v(t) (en vivo)</div>
        <div class="graph-wrap">
          <canvas id="graph" width="360" height="150" style="width:100%;background:rgba(255,255,255,0.01);border-radius:6px"></canvas>
        </div>
      </div>

      <div style="margin-top:8px" class="log" id="log"></div>

      <div style="margin-top:8px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px">
        <div class="small-muted" style="margin-bottom:6px;font-weight:600">üìö Ecuaciones F√≠sicas</div>
        <div style="font-size:11px;color:var(--muted);line-height:1.6">
          <div style="margin-bottom:4px"><strong>Aceleraci√≥n:</strong> a = (g¬∑sin(Œ∏)) / (1 + k)</div>
          <div style="margin-bottom:4px"><strong>Factor k:</strong> Esfera=2/5, Cilindro=1/2, Aro=1</div>
          <div style="margin-bottom:4px"><strong>Velocidad:</strong> v(t) = a¬∑t</div>
          <div style="margin-bottom:4px"><strong>Posici√≥n:</strong> s(t) = ¬Ω¬∑a¬∑t¬≤</div>
          <div style="margin-bottom:4px"><strong>Fricci√≥n:</strong> f = mg¬∑sin(Œ∏) - ma</div>
          <div><strong>Condici√≥n:</strong> f ‚â§ Œº¬∑N (rodadura sin deslizamiento)</div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

  <script>
  const g = 9.80665; // Aceleraci√≥n gravitacional (m/s¬≤)
  // Coeficiente de fricci√≥n est√°tica (asumido suficiente para rodadura sin deslizamiento)
  const MU_STATIC = 1.0; // Valor alto para garantizar rodadura sin deslizamiento
  const appState = {
    thetaDeg: 20,
    h: 1.2,
    R: 0.1,
    m: 1.0
  };

  // Escala visual: 1 metro f√≠sico = 150 pixeles 3D
  const SCALE = 150;

  // --- Clases F√≠sicas ---
  /**
   * Clase que representa un cuerpo r√≠gido en rodadura sin deslizamiento
   * Ecuaci√≥n de aceleraci√≥n: a = (g¬∑sin(Œ∏)) / (1 + k)
   * donde k es el factor de inercia rotacional
   */
  class RollingBody {
    constructor(name, type, zOffset){
      this.name = name; this.type = type; 
      this.zOffset = zOffset; 
      this.reset();
    }
    reset(){
      this.s = 0; // Posici√≥n a lo largo de la rampa (m)
      this.v = 0; // Velocidad lineal (m/s)
      this.a = 0; // Aceleraci√≥n lineal (m/s¬≤)
      this.w = 0; // Velocidad angular (rad/s)
      this.finished = false;
      this.samples = []; // Muestras para gr√°ficas
      this.trail = []; // Almacena posiciones 's' para el rastro
      this.friction = 0; // Fuerza de fricci√≥n est√°tica necesaria (N)
      this.frictionValid = true; // Indica si la fricci√≥n es suficiente
    }
    /**
     * Factor de inercia rotacional k = I/(mR¬≤)
     * Esfera s√≥lida: k = 2/5
     * Cilindro s√≥lido: k = 1/2
     * Aro: k = 1
     */
    k(){ 
      if(this.type === 'sphere') return 2/5;
      if(this.type === 'cyl') return 1/2;
      return 1.0; 
    }
    /**
     * Aceleraci√≥n te√≥rica para rodadura sin deslizamiento
     * a = (g¬∑sin(Œ∏)) / (1 + k)
     */
    theoreticalAcceleration(thetaRad){ 
      return (g * Math.sin(thetaRad)) / (1 + this.k()); 
    }
  }

  const sphereBody = new RollingBody('Esfera', 'sphere', -60);
  const cylBody = new RollingBody('Cilindro', 'cyl', 0);
  const ringBody = new RollingBody('Aro', 'ring', 60);
  const bodies = [sphereBody, cylBody, ringBody];

  // --- Estado Global ---
  let running = false;
  let paused = false;
  let t_sim = 0;
  let lastMillis = 0;
  let s_end = 0;
let tiempoFinalEsfera=null;
let tiempoFinalCilindro=null;
let tiempoFinalAro=null;

  // Canvas params
  let canvasW = 800, canvasH = 600;
  const graph = { el: null, ctx: null };

  // --- Helpers ---
  function $(id){ return document.getElementById(id); }
  function radians(d){ return d * Math.PI / 180; }
  function log(msg){ const el = $('log'); el.innerHTML = `<div>[${t_sim.toFixed(2)}] ${msg}</div>` + el.innerHTML; }

  // --- P5 Setup ---
  function setupSketch(){
    const holder = document.getElementById('sketch-holder');
    const rect = holder.getBoundingClientRect();
    canvasW = rect.width;
    canvasH = rect.height;

    // Crear canvas WEBGL
    const c = createCanvas(canvasW, canvasH, WEBGL);
    c.parent(holder);
    
    // C√°mara inicial
    camera(0, -200, 600, 0, 0, 0, 0, 1, 0);
    
    updatePhysicsParams();
    
    // Graph init
    graph.el = document.getElementById('graph');
    graph.ctx = graph.el.getContext('2d');
    updateUI();
  }

  window.addEventListener('resize', () => {
     if(window._rsz) clearTimeout(window._rsz);
     window._rsz = setTimeout(() => {
       const holder = $('sketch-holder');
       const rect = holder.getBoundingClientRect();
       resizeCanvas(rect.width, rect.height);
     }, 150);
  });

  /**
   * Actualiza par√°metros f√≠sicos derivados
   * Longitud de la rampa: s_end = h / sin(Œ∏)
   * donde h es la altura y Œ∏ es el √°ngulo de inclinaci√≥n
   */
  function updatePhysicsParams(){
    const theta = radians(appState.thetaDeg);
    s_end = (Math.sin(theta) > 1e-6) ? appState.h / Math.sin(theta) : 0;
  }

  function resetSim(){
    t_sim = 0; lastMillis = millis();
    running = false; paused = false;
    bodies.forEach(b => b.reset());
    $('status').innerText = 'Detenido';
    log('Reset.');
    drawGraph();
    updateUI();
  }

  function startSim(){
    bodies.forEach(b => b.reset());
    t_sim = 0; lastMillis = millis();
    running = true; paused = false;
    $('status').innerText = 'Corriendo';
    log('Iniciando...');
  }

  /**
   * Integraci√≥n num√©rica de las ecuaciones de movimiento
   * Usa el m√©todo de Euler expl√≠cito: v(t+dt) = v(t) + a¬∑dt, s(t+dt) = s(t) + v¬∑dt
   */
  function stepPhysics(dt){
    const theta = radians(appState.thetaDeg);
    updatePhysicsParams();
    
    bodies.forEach(b => {
      if(b.finished) {
         b.samples.push({t:t_sim, v:b.v});
         return;
      }
      
      // Aceleraci√≥n te√≥rica seg√∫n ecuaci√≥n: a = (g¬∑sin(Œ∏)) / (1 + k)
      const a = b.theoreticalAcceleration(theta);
      b.a = a;
      
      // Integraci√≥n num√©rica (Euler expl√≠cito)
      b.v += a * dt;
      b.s += b.v * dt;
      b.w = b.v / appState.R; // Velocidad angular: œâ = v/R (condici√≥n de rodadura)
      
      // Fricci√≥n est√°tica necesaria para rodar sin deslizar
      // f = mg¬∑sin(Œ∏) - ma (fuerza neta en direcci√≥n del movimiento)
      b.friction = (appState.m * g * Math.sin(theta)) - (appState.m * a);
      
      // Fuerza normal: N = mg¬∑cos(Œ∏)
      const N = appState.m * g * Math.cos(theta);
      
      // Validaci√≥n: f ‚â§ Œº¬∑N (condici√≥n para rodadura sin deslizamiento)
      const maxFriction = MU_STATIC * N;
      b.frictionValid = Math.abs(b.friction) <= maxFriction;
      
      if(!b.frictionValid && b.friction > 0){
        log(`‚ö†Ô∏è ${b.name}: Fricci√≥n insuficiente! f=${b.friction.toFixed(3)}N > ŒºN=${maxFriction.toFixed(3)}N`);
      }

      // Guardar muestras para gr√°ficas
      b.samples.push({t:t_sim, v:b.v});
      
      // Guardar rastro cada cierto tiempo o distancia
      if(b.trail.length === 0 || b.s - b.trail[b.trail.length-1] > 0.02) {
          b.trail.push(b.s);
      }

      if(b.s >= s_end){
        b.s = s_end;
        b.finished = true;
        b.trail.push(s_end);
        
log(`${b.name} finaliz√≥.`);
if(b.type === "sphere" && tiempoFinalEsfera===null) tiempoFinalEsfera = t_sim;
if(b.type === "cyl" && tiempoFinalCilindro===null) tiempoFinalCilindro = t_sim;
if(b.type === "ring" && tiempoFinalAro===null) tiempoFinalAro = t_sim;

      }
    });
    
    if(bodies.every(b => b.finished)){
      running = false;
      $('status').innerText = 'Finalizado';
    }
  }

  // --- P5 Draw Loop (WEBGL) ---
  function setup(){ setupSketch(); }

  function draw(){
    background(10, 20, 35); 
    
    // Luces
    ambientLight(100);
    pointLight(255, 255, 255, 100, -400, 300);
    directionalLight(200, 200, 200, 1, 1, -1);

    orbitControl(1, 1, 0.1);

    if(running && !paused){
      const now = millis();
      let dt = (now - lastMillis)/1000.0;
      if(dt>0.1) dt=0.1; 
      stepPhysics(dt);
      lastMillis = now;
      t_sim += dt;
    } else {
      lastMillis = millis();
    }

    // --- Escena 3D ---
    const rampLen = s_end * SCALE; 
    const rampWidth = 240;
    const rampThickness = 10;
    const theta = radians(appState.thetaDeg);

    // Mover mundo
    push();
    translate(-rampLen * Math.cos(theta)/2 + 100, 100, 0); 

    // Rampa
    push();
    rotateZ(theta);
    fill(30, 40, 50); noStroke();
    translate(rampLen/2, rampThickness/2, 0);
    box(rampLen, rampThickness, rampWidth);
    
    // L√≠neas de carril
    translate(0, -rampThickness/2 - 1, 0);
    stroke(255,255,255,20); strokeWeight(1);
    line(-rampLen/2, 0, -30, rampLen/2, 0, -30);
    line(-rampLen/2, 0, 30, rampLen/2, 0, 30);
    
    pop(); // fin transform rampa

    // Cuerpos
    push();
    rotateZ(theta);
    
    const showForces = $('showForces').checked;
    const showTrail = $('showTrail').checked;
    
    bodies.forEach(b => {
      const rVis = appState.R * SCALE;
      const distVis = b.s * SCALE;
      
      push();
      translate(distVis, -rVis, b.zOffset); // Posici√≥n CM
      
      // Dibujar objeto rotado
      push();
      noStroke();
      specularMaterial(255); shininess(20);
      
      if(b.type === 'sphere'){
        rotateZ(b.s / appState.R);
        fill(255, 159, 28); sphere(rVis);
        stroke(0,0,0,50); strokeWeight(2); noFill(); ellipse(0,0, rVis*2.1, rVis*2.1);
      } else if (b.type === 'cyl'){
        rotateZ(b.s / appState.R);
        fill(43, 208, 163); rotateX(HALF_PI); cylinder(rVis, 40);
        push(); translate(0, 21, 0); fill(30,160,120); circle(0,0,rVis*1.8); pop();
        push(); translate(0, -21, 0); fill(30,160,120); circle(0,0,rVis*1.8); pop();
      } else if (b.type === 'ring'){
        // Rotar alrededor del eje Z (vertical) como los otros objetos
        rotateZ(b.s / appState.R);
        fill(165, 180, 252); torus(rVis - (rVis*0.15), rVis*0.3); 
        stroke(100,100,255); strokeWeight(2); line(0,0,0, rVis,0,0); line(0,0,0, 0,rVis,0);
      }
      
      pop(); // fin objeto

      // --- VECTORES DE FUERZA ---
      if(showForces && !b.finished){
        const mg_sin = appState.m * g * Math.sin(theta);
        const f = b.friction;
        const fScale = 8; // Escala visual para los vectores

        // 1. mg sin(theta) - Desde el CM, apuntando hacia abajo de la rampa (+X)
        drawArrow3D(mg_sin * fScale, color(70,130,180), 0, 0); // Azul

        // 2. Fricci√≥n - Desde el punto de contacto (CM + rVis en Y), apuntando arriba (-X)
        push();
        translate(0, rVis, 0); // Mover a base
        drawArrow3D(f * fScale, color(220,80,80), Math.PI, 0); // Rojo, rotado 180
        pop();
      }
      
      pop(); // fin translate objeto

      // --- RASTRO (TRAIL) ---
      if(showTrail && b.trail.length > 1){
          noFill();
          stroke(255, 255, 255, 50);
          strokeWeight(2);
          beginShape();
          for(let i=0; i<b.trail.length; i++){
              // Dibujar levemente por encima de la rampa (-2 en Y)
              vertex(b.trail[i] * SCALE, -2, b.zOffset);
          }
          vertex(distVis, -2, b.zOffset); // Conectar con pos actual
          endShape();
      }
    });
    
    pop(); // fin rotaci√≥n mundo
    pop(); // fin traslaci√≥n mundo

    updateUI();
    drawGraph();
  }

  // Funci√≥n para dibujar ejes de coordenadas
  function drawAxes(){
    const axisLength = 100;
    const arrowSize = 8;
    const labelOffset = 15;
    
    push();
    // Eje X - Rojo
    stroke(255, 0, 0);
    strokeWeight(2);
    line(0, 0, 0, axisLength, 0, 0);
    // Flecha X
    push();
    translate(axisLength, 0, 0);
    fill(255, 0, 0);
    noStroke();
    cone(arrowSize, arrowSize * 1.5);
    pop();
    // Etiqueta X
    push();
    translate(axisLength + labelOffset, 0, 0);
    fill(255, 0, 0);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(16);
    text('X', 0, 0);
    pop();
    
    // Eje Y - Verde
    stroke(0, 255, 0);
    strokeWeight(2);
    line(0, 0, 0, 0, axisLength, 0);
    // Flecha Y
    push();
    translate(0, axisLength, 0);
    rotateX(-HALF_PI);
    fill(0, 255, 0);
    noStroke();
    cone(arrowSize, arrowSize * 1.5);
    pop();
    // Etiqueta Y
    push();
    translate(0, axisLength + labelOffset, 0);
    fill(0, 255, 0);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(16);
    text('Y', 0, 0);
    pop();
    
    // Eje Z - Azul
    stroke(0, 0, 255);
    strokeWeight(2);
    line(0, 0, 0, 0, 0, axisLength);
    // Flecha Z
    push();
    translate(0, 0, axisLength);
    rotateY(HALF_PI);
    fill(0, 0, 255);
    noStroke();
    cone(arrowSize, arrowSize * 1.5);
    pop();
    // Etiqueta Z
    push();
    translate(0, 0, axisLength + labelOffset);
    fill(0, 0, 255);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(16);
    text('Z', 0, 0);
    pop();
    
    pop();
  }

  // Funci√≥n para dibujar el eje de rotaci√≥n de un objeto
  function drawRotationAxis(body){
    const axisLength = 80;
    const arrowSize = 6;
    
    push();
    noFill();
    
    // Todos los objetos rotan alrededor del eje Z (vertical)
    let col;
    if(body.type === 'sphere'){
      col = color(255, 255, 0); // Amarillo
    } else if(body.type === 'cyl'){
      col = color(0, 255, 255); // Cian
    } else if(body.type === 'ring'){
      col = color(255, 0, 255); // Magenta
    }
    
    // Eje Z (vertical) para todos
    stroke(col);
    strokeWeight(2);
    line(0, 0, -axisLength/2, 0, 0, axisLength/2);
    // Flecha positiva
    push();
    translate(0, 0, axisLength/2);
    fill(col);
    noStroke();
    cone(arrowSize, arrowSize * 1.5);
    pop();
    // Flecha negativa
    push();
    translate(0, 0, -axisLength/2);
    rotateY(PI);
    fill(col);
    noStroke();
    cone(arrowSize, arrowSize * 1.5);
    pop();
    
    pop();
  }

  // Helper para dibujar flechas 3D
  // len: longitud, col: color, rotZ: rotaci√≥n en plano (0 = +X), yOffset: altura
  function drawArrow3D(len, col, rotZ, yOffset){
      if(len < 1) return;
      push();
      fill(col); noStroke();
      rotateZ(rotZ); // Orientar
      rotateZ(-HALF_PI); // Cilindro se dibuja en Y, rotar para que apunte a X
      translate(0, len/2, 0); 
      cylinder(2, len); // Cuerpo
      translate(0, len/2, 0);
      cone(6, 12); // Punta
      pop();
  }

  // --- UI & Graph & History ---
  function updateUI(){
    if(!sphereBody) return;
    $('t').innerText = t_sim.toFixed(3);
    $('angle-val').innerText = appState.thetaDeg + '¬∞';
    $('height-val').innerText = appState.h.toFixed(2) + ' m';
    $('radius-val').innerText = appState.R.toFixed(3) + ' m';
    $('mass-val').innerText = appState.m.toFixed(1) + ' kg';
    $('tangle').innerText = appState.thetaDeg;
    
    const theta = radians(appState.thetaDeg);
    $('a_theo').innerText = `${sphereBody.theoreticalAcceleration(theta).toFixed(2)} / ${cylBody.theoreticalAcceleration(theta).toFixed(2)} / ${ringBody.theoreticalAcceleration(theta).toFixed(2)}`;
    
    $('v_sphere').innerText = sphereBody.v.toFixed(3);
    $('v_cyl').innerText = cylBody.v.toFixed(3);
    $('v_ring').innerText = ringBody.v.toFixed(3);

$('posText').innerText = sphereBody.s.toFixed(3);
$('omegaText').innerText = sphereBody.w.toFixed(3);
$('tEsfera').innerText = tiempoFinalEsfera?.toFixed(3) ?? "--";
$('tCilindro').innerText = tiempoFinalCilindro?.toFixed(3) ?? "--";
$('tAro').innerText = tiempoFinalAro?.toFixed(3) ?? "--";

  }

  /**
   * Dibuja la gr√°fica v(t) con datos simulados y te√≥ricos
   */
  function drawGraph(){
    if(!graph.ctx) return;
    const ctx = graph.ctx;
    const w = graph.el.width; const h = graph.el.height;
    ctx.clearRect(0,0,w,h);
    
    // Ejes
    ctx.strokeStyle = '#223'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(30, h-20); ctx.lineTo(w, h-20); ctx.stroke(); 
    ctx.beginPath(); ctx.moveTo(30, h-20); ctx.lineTo(30, 0); ctx.stroke(); 
    
    let maxT = 0.1; let maxV = 0.1;
    const allData = [];
    
    // Recolectar datos simulados actuales
    bodies.forEach(b => {
        if(b.samples.length>0) {
          allData.push({
            color: b.type=='sphere'?'#ff9f1c':(b.type=='cyl'?'#2bd0a3':'#a5b4fc'), 
            data: b.samples
          });
        }
    });

    // Encontrar m√°ximos para escalado
    allData.forEach(s => {
        s.data.forEach(p => {
            if(p.t > maxT) maxT = p.t;
            if(p.v > maxV) maxV = p.v;
        });
    });
    
    if(maxT < 0.1) maxT = 0.1;
    if(maxV < 0.1) maxV = 0.1;

    // Dibujar curvas
    allData.forEach(s => {
       if(s.data.length < 2) return;
       ctx.beginPath(); 
       ctx.strokeStyle = s.color; 
       ctx.lineWidth = 2;
       ctx.setLineDash([]);
       
       s.data.forEach((p, i) => {
         const x = 30 + (p.t / maxT) * (w-40);
         const y = (h-20) - (p.v / maxV) * (h-30);
         if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
       });
       ctx.stroke();
    });
    
    ctx.fillStyle='#aaa'; ctx.font='10px Arial';
    ctx.fillText(maxT.toFixed(1)+'s', w-25, h-8);
    ctx.fillText(maxV.toFixed(1)+'m/s', 2, 10);
  }

  // --- EXPORT ---
  function exportSnapshot(){
      let csv = "t,body,v,s,a\n";
      bodies.forEach(b => {
          b.samples.forEach((s, i) => {
              csv += `${s.t.toFixed(4)},${b.name},${s.v.toFixed(4)},${(b.trail[i]||0).toFixed(4)},${b.a.toFixed(4)}\n`;
          });
      });
      downloadCSV(csv, `snapshot_3d_${Date.now()}.csv`);
  }
  
  function downloadCSV(content, filename){
      const blob = new Blob([content], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=filename; a.click();
  }

  // Event Listeners
  window.addEventListener('load', () => {
    $('angle').addEventListener('input', (e)=>{ appState.thetaDeg = parseFloat(e.target.value); updateUI(); });
    $('height').addEventListener('input', (e)=>{ appState.h = parseFloat(e.target.value); updateUI(); });
    $('radius').addEventListener('input', (e)=>{ appState.R = parseFloat(e.target.value); updateUI(); });
    $('mass').addEventListener('input', (e)=>{ appState.m = parseFloat(e.target.value); updateUI(); });
    
    $('start').addEventListener('click', startSim);
    $('pause').addEventListener('click', () => { paused = !paused; $('pause').innerText = paused ? 'Reanudar' : 'Pausar'; });
    $('reset').addEventListener('click', resetSim);
    $('viewReset').addEventListener('click', () => { camera(0, -200, 600, 0, 0, 0, 0, 1, 0); });
    
    $('exportSnapshot').addEventListener('click', exportSnapshot);
    $('showForces').addEventListener('change', () => { if(!running) redraw(); });
  });
  </script>
</body>
</html>